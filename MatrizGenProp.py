# -*- coding: utf-8 -*-
"""Entrega 3

Automatically generated by Colaboratory.

Original file is located at
    https://colab.research.google.com/drive/1E_vocSbp2vDXiu7SycqS5JONsYYHeGLt
"""

import numpy as np
import math 
#Matriz generadora
matriz_gen = np.array([[1,0,0,1],[0,1,0,1],[0,0,1,1]])

#espacio f_2^3
seq = np.array([[0,0,0],[0,0,1],[0,1,0],[0,1,1],[1,0,0],[1,0,1],[1,1,0],[1,1,1]])

#espacio f_2^4
esp = np.array([[0,0,0,0], [0,0,0,1], [0,0,1,0], [0,0,1,1], [0,1,0,0], [0,1,0,1], [0,1,1,0], [0,1,1,1], [1,0,0,0], [1,0,0,1], [1,0,1,0], [1,0,1,1], [1,1,0,0], [1,1,0,1], [1,1,1,0], [1,1,1,1]])

#array resultante con todos los codewords, cada bit separado por coma 
codigo_res = []

#string final con todos los codewords, sin comas entre los numeros de codewords 
codigo_print = "C = {"
codewords = []
num_filas = len(matriz_gen)
num_col = len(matriz_gen[0])

#Subrutina que crea el codigo a partir de la matriz generadora
def crear_codigo(matriz):
  global codigo_print
  global codewords
  for i in range(0, len(seq)):
    #se multiplica cada elemento del espacio con la matriz
    res = (seq[i][0]*matriz_gen[0]) + (seq[i][1]*matriz_gen[1]) + (seq[i][2]*matriz_gen[2])
    #se añade el codeword generado 'res' a el codigo y se aplica la operación módulo 2, en el caso de que el numero no pertenezca a F2 
    codigo_res.append(res%2)
    #Descomentar el print para ver el proceso que hace la variable res + su resultado a F2
    #print("("+str(seq[i][0])+")*"+str(matriz_gen[0])+" + ("+str(seq[i][1])+")*"+str(matriz_gen[1])+" + ("+str(seq[i][2])+")*"+str(matriz_gen[2])+" = "+str(res%2))

  #bucle para mostrar el codigo binario en su forma deseada.
  j = 0
  for codigo in codigo_res:
    if j < len(codigo_res)-1:
      codigo_print += str(codigo).replace(" ", "").replace("[", "").replace("]", "") + "," 
    else: 
      codigo_print += str(codigo).replace(" ", "").replace("[", "").replace("]", "") + "}" 
    codewords.append(str(codigo).replace(" ", "").replace("[", "").replace("]", ""))
    j = j + 1
  print(codigo_print) 
crear_codigo(matriz_gen)

#Función para comparar distancias entre dos strings
def hamming(s1, s2):
  count=0
  for i in range(len(s1)):
    if s1[i] != s2[i]:
      count+=1
  return count

#Función para determinar distancia minima
def distancia_min(codigo):
  dist_min = hamming(codigo[0], codigo[1])
  for i in range(0,len(codigo)):
    if i < len(codigo)-1:
      if dist_min > hamming(codigo[i], codigo[i+1]):
        dist_min = hamming(codigo[i], codigo[i+1])
  return dist_min

#Función para determinar la dimensión del código
def dimension(codigo, q):
  return int(math.log(len(codigo),q))

#Función para determinar el inverso de un número en F_q
def inverso(num, q):
  for i in range(q):
    if ((i+num)%2 == 0):
      return i

#Subrutina para determinar la matriz de control, teniendo en cuenta que ya la matriz está en su forma estándar
Hc = []
def H(G, n, k, q):
  A = []
  #Determinamos el tamaño de A y los valores que la conforman, y los añadimos a una matriz ya traspuesta con sus valores inversos
  for i in range(k, n):
    for j in range(k):
      A.append(inverso(G[j][i], q))
  for elem in A:
    Hc.append(elem)
  #Se añade la matriz identidad de tamaño n-k, en este caso, es simplemente 1
  Hc.append(1)
  #Se muestra la matriz de control como se desea
  Hprint = "H = ("
  for f in Hc:
    if j < len(Hc)-1:
      Hprint += str(f).replace(" ", "").replace("[", "").replace("]", "")  
    else: 
      Hprint += str(f).replace(" ", "").replace("[", "").replace("]", "")
    j = j + 1
  Hprint += ")"
  print(Hprint)

#Subrutina para determinar las clases laterales 
clases = []
def clsLat(C, numClases, espacio):
  clases.append(C)
  for elem in espacio:
    clsN = True
    #Suma el codigo con cada elemento del espacio y revisa si en la nueva clase de prueba hay algún elemento repetido con las clases 
    #ya existentes. Si es el caso, entonces no puede ser una clase nueva
    nC = (elem+C)%2
    for v in nC:
      for clase in clases: 
        for cw in clase:
          compare = v == cw
          if (compare.all()):
            clsN = False
    if (clsN == True):
      clases.append(nC)
  #Escribe las clases de forma deseada
  j = 1
  for clase in clases:
    clasesp = "Clase lateral "+str(j)+" = {"
    clasesp += str(clase).replace(" ", ",").replace("[", "").replace("]", "").replace("array", "").replace(",", "").replace("(", "").replace(")", ",").replace("\n", ",") + "}"
    if (j == 1):
      print(clasesp[:-2] + "}")
    else:
      print(clasesp) 
    j = j + 1
    
#Función para determinar la palabra con peso mínimo
def pesoMinimo(C):
  pesomin = 100
  #Compara todos los digitos de cada codeword, buscando aquellos distintos de 0
  #el codeword con menos digitos distintos de 0 es el de peso mínimo
  #si hay varios de igual valor, se toma el primero en orden de entrada
  for codeword in C:
    distCero = 0
    for i in range(len(codeword)):
      if (codeword[i]!=0):
        distCero+=1
    if(distCero < pesomin):
      pesomin = distCero
      lider = codeword
  return lider

#Subrutina para decodificar vectores y hallar el mensaje final
lid = []
def decodificar(v, H, clases):
  #Se hallan los líderes de las clases y sus síndromes, con lo que se forma la matriz
  for clase in clases:
    lider = pesoMinimo(clase)
    sindrome = 0
    for i in range(len(H)):
      sindrome += H[i] * lider[i]
    lid.append([lider, sindrome%2])
  sindromev = 0
  #Se halla el síndrome de v
  for i in range(len(H)):
    sindromev += H[i] * v[i]
  sindromev = sindromev%2
  #Se busca en la matriz con qué síndrome coincide y se resta el vector con el lider determinado, lo que nos da el mensaje final.
  for i in range(len(lid)):
    if(lid[i][1] == sindromev):
      liderc = lid[i][0]
  mensajeFinal = v-liderc
  #Se escribe el mensaje de forma deseada
  mensajePrint = "Al decodificar (1101), la palabra corregida está dada por: ("
  mensajePrint += str(mensajeFinal).replace("array","").replace("[","").replace("]","").replace(",","").replace(" ","")
  mensajePrint += ")"
  print(mensajePrint)

#Mostramos todos los valores requeridos
distmin = distancia_min(codewords)
parametros_codigo=[len(codewords[0]),dimension(codewords, 2),distmin]
print(parametros_codigo)
print("La longitud es ", len(codewords[0]))
print("La dimensión es ",dimension(codewords, 2))
print("La distancia mínima es de ", distmin)
print("La matriz de control es")
H(matriz_gen, len(codewords[0]), dimension(codewords, 2), 2)
print("La cantidad de clases laterales es: "+str(2**(4-3)))
clsLat(codigo_res, 2**(4-3), esp)
decodificar([1,1,0,1], Hc, clases)